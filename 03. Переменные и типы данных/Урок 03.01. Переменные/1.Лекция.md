Ruby / Урок 03.01. Переменные

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.Практика.md)

***

# 1. Идентификаторы Ruby

***Идентификатор*** - обычное имя используемое **Ruby** для присвоения имен переменным, методам, классам и т д.

**Ruby** — регистро-зависимый язык, прописные и строчные буквы в идентификаторах являются различными. 

>Все ключевые слова языка, за двумя исключениями, пишутся в нижнем регистре.

Это означает, что RRam и RAM – два разных идентификатора в Ruby.

До версии 2.0 язык использовал множество символов 7-битной кодировки **ASCII**. 
Начиная с версии 2.0 поддерживается **Unicode**, по умолчанию файлы исходного кода используют кодировку **UTF-8**. 
Все буквенные символы **Unicode** допускается использовать в идентификаторах наравне с английскими буквами. 
Полностью поддерживаются **Unicode**-строки.

## 1.1. Зарезервированные слова

Список ключевых слов **Ruby**

|          |        |       |        |       |       |        |       |
|----------|--------|-------|--------|-------|-------|--------|-------|
| alias    | and    | BEGIN | begin  | break | case  | class  | def   |
| defined? | do     | else  | elsif  | END   | end   | ensure | false |
| for      | if     | in    | module | next  | nil   | not    | or    |
| redo     | rescue | retry | return | self  | super | then   | true  |
| undef    | unless | until | when   | while | yield |        |       |

Эти зарезервированные слова не могут использоваться как постоянные или переменные имена. 
Однако они могут использоваться в качестве имен методов.

## 1.2. Соглашения об именовании

### 1.2.1. Стили именования

В языках программирования используются три основных стиля именования:

* *snake case (snake - змея)*
  
Между словами ставится знак подчеркивания (_).

*Пример*

```ruby
client_age = 10 
user_password = '123456' 
user_password_expiration_date = '12-12-2022'
```

* *camel case (camel - верблюд)*
  
Слово начинается с маленькой буквы и разделяются с помощью больших букв. 

*Пример*

```javascript
clientAge = 10
userPassword = '123456' 
userPasswordExpirationDate = '12-12-2020'
```

* *kebab case (kebab - шашлык)*
  
Слова разделяются дефисом.

*Пример*

```html
<input type="text" name="login" data-error-highlightcolor="red">
```

### 1.2.2. Соглашения об именовании в Ruby

В **Ruby** применяется **snake case** для именования переменных. 

Идентификаторы **Ruby** традиционно должны состоять из букв (A-Z, a-z), цифр (0-9) и 
знаков подчёркивания (_) и начинаться с буквы или знака подчёркивания. 
Идентификаторы **Ruby** не могут включать пробелы или неотображаемые символы, и не могут включать знаки пунктуации,
за исключением некоторых случаев.

**Ruby** использует соглашение об именовании:

* имена, начинающиеся с прописной буквы, обозначают **константы** и **классы**

* имена, начинающиеся со строчной буквы или одиночного знака подчёркивания, обозначают **локальные переменные** и **методы класса**

Также используются *префиксы* имён, определяющие *область видимости идентификатора*:

* префикс **@** обозначает переменную экземпляра

*Пример*

```ruby
@day_of_week = 'Monday'
@month = 'May'
@days = 10
```

* префикс **@@** обозначает переменную класса

*Пример*

```ruby
@@day_of_week = 'Monday'
@@month = 'May'
@@days = 10
```

* префикс **$** обозначает глобальную переменную или константу

*Пример*

```ruby
$day_of_week = 'Monday'
$month = 'May'
$days = 10
```

>Также он используется в именах предопределённых системных переменных.

* префикс **:** обозначает символ (экземпляр класса **Symbol**)

Для имён методов применяются *суффиксы*, обозначающие *назначение метода*:

* суффикс **!** обозначает деструктивный метод класса, 
то есть такой метод, вызов которого изменяет объект, для которого он вызван

* суффикс **?** обозначает предикат, 
то есть метод класса, возвращающий логическое значение

*Пример*

```ruby
obj.empty?        # Объект пуст? (истина/ложь)
Numeric.nonzero?  # Число не нуль? (истина/ложь)
obj.upcase!       # Перевести буквы в верхний регистр
obj.ident!        # Добавить отступы в строку
obj.capitalize!   # Сделать все слова с заглавной буквы
```

## 1.3. Разделители 

Пробелы, знаки табуляции, символы новой строки сами по себе лексемами не являются, а используются для разделения лексем,
которые без них объединились бы в большую лексему. Кроме этой основной функции по разделению лексем, пробельные символы, 
обычно игнорируются интерпретатором **Ruby** (в отличие от программ на **Python**) 
и используются лишь для форматирования программ, облегчая их чтение и понимание.

Однако, они используются для интерпретации неоднозначных утверждений.
Интерпретации этого типа вызывают предупреждения, когда опция -w включена.

*Пример:*

```ruby
a + b
a  +b
```

*Результат:*

Первая строка интерпретируется как a+b (Сложение двух локальных переменных).
Вторая строка интерпретируется как  a(+b) (Вызов метода).

### 1.3.1. Символ новой строки

**Ruby** интерпретирует точки с запятой и символы новой строки как конец оператора.
Однако, если **Ruby** встречает операторы, такие как +, – или обратная косая черта в конце строки,
они указывают на продолжение оператора.

Начиная с **Ruby** 1.9 правила завершения оператора изменились.
Если первый не являющийся пробелом символом строки будет точка, то строка рассматривается как строка-продолжение, 
и предшествующий символ новой строки не является признаком завершения оператора.

### 1.3.2. Пробел

При определенных обстоятельствах скобки в вызовах методов могут быть опущены.
Это дает использовать методы в качестве операторов, что является важной составляющей **Ruby**.
Однако открывается опасная зависимость от скобок.

*Пример:*

```ruby
f(1+2)+3
f (1+2)+3
```

*Результат:*

Первая строка интерпретируется как вычисление функции от 1+2 и далее сложение с 3.
Вторая строка интерпретируется как вычисление функции от (1+2)+3.

***

# 2. Переменные и константы

И константы и переменные в **Ruby** хранят ссылку на объект.
Их существование начинается в момент первого присвоения этой ссылки (включая nil).
Любой переменной или константе в **Ruby** может быть присвоена ссылка на любой объект.

В **Ruby** переменные и константы не имеют типа, однако объекты на которые ссылаются переменные и константы, тип имеют.
**Ruby** - язык с динамическим контролем типов, поэтому проверка типов осуществляется в момент выполнения операций,
но не в момент присвоения переменной или константе ссылки на объект.

## 2.1. Присвоения значения

Присвоение значения переменной или константе выполняется с помощью =.

*Пример*

```ruby
a = 10
b = 20
c = 30
d = 40
```

В **Ruby** можно выполнять паралелльное присвоение значений.

*Пример*

```ruby
a, b, c, d = 10, 20, 30, 40
```

## 2.2. Глобальные переменные

***Глобальная переменная*** 

* имя *глобальной переменной* начинается с префикса **$**
* область видимости *глобальной переменной* ни чем не ограничена
* инициализация *глобальной переменной* необязательна  
* неинициализированная *глобальная переменная* имеет значение **nil** (создает предупрежедение с параметром -w)
* присвоение глобальных переменных имеет глобальный статус

>Не рекомендуется использовать глобальные переменные.

*Пример*

```ruby
$global_variable = 10

class Class1
  def print_global
    puts "Глобальная переменная в Class1 есть #{}$global_variable"
  end
end

class Class2
  def print_global
    puts "Глобальная переменная в Class2 есть #$global_variable"
  end
end

class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global
```

*Результат*

```text
Глобальная переменная в Class1 есть 10
Глобальная переменная в Class2 есть 10
```

## 2.3. Переменные класса

***Переменная класса***

* имя *переменной класса* начинается с префикса **@@**
* область видимости *переменной класса* весь класса (общий для всех экземпляров)
* инициализация *переменной класса* обязательна (до использования в определениях методов)
* неинициализированная *переменная класса* вызывает ошибку при обращении
* переопределение *переменной класса* создает предупреждения с параметром -w

*Пример*

```ruby
class Dinosaur
  @@classification = "Like a Reptile, but like a bird"
  
  def self.classification
    @@classification
  end
end

puts Dinosaur.classification
```

*Результат*

```text
Like a Reptile, but like a bird
```

Переменная класса может быть перезаписана в классе потомке.

*Пример*

```ruby
class TRex < Dinosaur
  @@classification = "Big teeth bird!"
end

TRex.classification
Dinosaur.classification
```

*Результат*

```text
Like a Reptile, but like a bird
Big teeth bird!
Big teeth bird!
```

Переменные класса определенные в внутри модуля не будут перезаписывать переменные класса внутри клааса в который он встраивается.

*Пример*

```ruby
module SomethingStrange
  @@classification = "Something Strange"
end

class DuckDinosaur < Dinosaur
  include SomethingStrange
end

DuckDinosaur.class_variables # [:@@classification]
SomethingStrange.class_variables # [:@@classification]
DuckDinosaur.classification
```

*Результат*
```text
Big teeth bird!
```

## 2.4. Переменные экземпляра класса

***Переменная экземпляра класса*** 

* имя *переменной экземпляра класса* начинаются с префикса **@**
* область видимости *переменной экземпляра класса* единственный инстанс класса
* инициализация *переменной экземпляра класса* необязательна
* неинициализированная *переменная экземпляра класса* имеет значение **nil** (создает предупреждение с параметром -w)

*Пример*

```ruby
class Dinosaur
  @base_sound = "rawrr"
  
  def initialize(sound = nil)
    @sound = sound || self.class.base_sound
  end
  
  def speak
    @sound
  end
  
  def try_to_speak
    @base_sound
  end
  
  def count_and_store_sound_length
    @sound.chars.each_with_index do |char, i|
      @sound_length = i + 1
      p "#{char}: #{sound_length}"
    end
  end
  
  def sound_length
    @sound_length
  end
  
  def self.base_sound
    @base_sound
  end
end

dino_1 = Dinosaur.new
dino_2 = Dinosaur.new "grrr"
Dinosaur.base_sound # rawrr
dino_2.speak # grrr
```

*Результат*

```text
rawrr
grrr
```

Переменная экемпляра класса определенная в классе будет доступна только на уровне класса.

*Пример*

```ruby
dino_1.try_to_speak
```

*Результат*

```text
nil
```

Однако ее можно использовать.

*Пример*

```ruby
dino_1.speak
```

*Результат*

```text
rawwr
```

Переменные экземпляра класса могут быть определены везде в классе, даже внутри блока.

*Пример*

```ruby
dino_1.count_and_store_sound_length # ["r", "a", "w", "r", "r"]
dino_1.sound_length
```

*Результат*

```text
# "r: 1"
# "a: 2"
# "w: 3"
# "r: 4"
# "r: 5"
5
```

Переменная экземпляра класса не разделяется между разными экземплярами класса.

*Пример*

```ruby
dino_2.sound_length
```

*Результат*

```text
nil
```

Переменные экземпляра класса можно использовать, чтобы создать переменные уровня класса, которые смогут переписать классы потомки.

*Пример*

```ruby
class DuckDuckDinosaur < Dinosaur
  @base_sound = "quack quack"
end

duck_dino = DuckDuckDinosaur.new
duck_dino.speak # quack quack
DuckDuckDinosaur.base_sound # quack quack

Dinosaur.base_sound # rawrr
```

*Результат*

```text
quack quack
quack quack
rawrr
```

## 2.5. Локальные переменные

***Локальные переменные*** 

* имя *локальной переменной* начинается со строчной буквы или _
* область видимости *локальной переменной* может быть ограничена классом, модулем, методом, блоком
* инициализация *локальной переменной* необязательна  
* неинициалзированная *локальная переменная* интерпретируется как вызов метода без аргументоа

### 2.5.1. Локальная переменная в классе и модуле

Локальная переменная не может быть передана в класс или модуль.

### 2.5.2. Локальная переменная в методе

Локальная переменная объявленная в методе может быть использована только в методе.

*Пример*

```ruby
def some_method
    method_scope_var = "hi there"
    p method_scope_var
end
some_method
```

*Результат*

```text
hi there
```

Попытка обратиться к локальной переменной мне метода вызовет ошибку.

*Пример*

```ruby
def some_method
  method_scope_var = "hi there"
  p method_scope_var
end
method_scope_var
````

*Результат*

```text
NameError: undefined local variable or method `method_scope_var'
```

Локальная переменная не может быть передана в метод

*Пример*

```ruby
my_variable = "foo"
def some_method
  puts "you can't use the local variable in here, see? #{my_variable}"
end
some_method
````

*Результат*

```text
# NameError: undefined local variable or method `my_variable'
```

### 2.5.3. Локальная переменная внутри блока do...end или {}

Локальная переменная объявленная внутри блока **do...end** или **{}** может быть использована только внутри метода.

*Пример*

```ruby
2.times do |n|
  local_var = n + 1
  p local_var
end
````

*Результат*

```text
1
2
```

Попытка обратиться к локальной переменной вне блока вызовет ошибку.

*Пример*

```ruby
2.times do |n|
  local_var = n + 1
end
local_var
````

*Результат*

```text
NameError: undefined local variable or method `local_var'
```

Локальная переменная может быть передана в блок.

*Пример*

```ruby
my_variable = "foo"
my_variable.split("").each_with_index do |char, i|
  puts "The character in string '#{my_variable}' at index #{i} is #{char}"
end
````

*Результат*

```text
The character in string 'foo' at index 0 is f
The character in string 'foo' at index 1 is o
The character in string 'foo' at index 2 is o
```

Локальная переменная передаваемая в блок перекрывает, но не перезаписывает раннее обяъвленную переменную с таким же именем.

*Пример*

```ruby
overshadowed = "sunlight"
["darkness"].each do |overshadowed|
  p overshadowed
end
```

*Результат*

```text
darkness
```

### 2.5.4. Локальная переменная в конструкциях ветвления if или case

Локальная переменная в конструкциях ветвления if или case может быть использована в родительском контексте.

*Пример*

```ruby
if true
  usable = "yay"
end
p usable
```

*Результат*

```text
yay
```

## 2.6. Константы

***Константы*** 

* имя *константы* начинаются с прописной буквы
* область видимости *константы*, определенной в классе или модуле - этот класс или модуль.
* область видимости *константы*, определенной вне класса или модуля - везде
* инициализация *константы* обязательна
* неинициализированная *константа* вызывает ошибку при обращении
* переопределение *константы* разрешено  
* определение *константы* в методе запрещено


*Пример*

```ruby
class Example
  VAR1 = 100
  VAR2 = 200
  def show
    puts "Значение первой константы есть #{VAR1}"
    puts "Значение второй константы есть #{VAR2}"
  end
end

object = Example.new()
object.show
```

*Результат*

```text
Значение первой константы есть 100
Значение второй константы есть 200
```

***

# 3. Псевдопеременные, предопределенные переменные и предопределенные константы

## 3.1. Псевдопеременные

***Псевдопременные*** - специальные переменные, которые ведут себя как константы, и им нельзя присвоить значения.

| Имя переменной | Описание                                                    |
|----------------|-------------------------------------------------------------|
| self           | Объект, выполняющий данный метод                            |
| nil            | Единственный экземпляр класса NilClass (представляет false) |
| true           | Единственный экземпляр класса TrueClass (ИСТИНА)            |
| false          | Единственный экземпляр класса FalseClass (ЛОЖЬ)             |
| \_\_FILE__     | Имя текущего файла                                          |
| \_\_LINE__     | Номер строки выполнения в текущем файле                     |

## 3.2. Предопределенные переменные

***Предопределенные переменные*** - специальные переменные, которые содержат в себе специальные данные.

| Имя переменной | Описание                                                                                               |
|----------------|--------------------------------------------------------------------------------------------------------|
| $!             | Текст сообщения об исключении, установленном инструкцией 'raise'                                       |
| $@             | Массив стека вызовов на момент последнего исключения                                                   |
| $&             | Строка, соответствующая последнему успешному совпадению при поиске по шаблону                          |
| $\`            | Содержит строку слева от шаблона последнего успешного поиска                                           |
| $'             | Содержит строку справа от шаблона последнего успешного поиска                                          |
| $+             | Содержит последнюю группу символов, соответствующую шаблону последнего успешного поиска                |
| $1             | Содержит N-ю группу символов, соответствующую шаблону последнего успешного поиска. Может быть больше 1 |
| $~             | Информация о шаблоне последнего поиска                                                                 |
| $=             | Флаг нечувствительного к регистру поиска. По умолчанию nil                                             |
| $/             | Разделитель записей. По умолчанию перевод строки                                                       |
| $\             | Разделитель записей при выводе для print и IO#write. По умолчанию nil                                  |
| $,             | Разделитель полей при выводе для print и Array#join                                                    |
| $;             | Разделитель по умолчанию для String#split                                                              |
| $.             | Номер строки, прочитанной из файла                                                                     |
| $>             | Вывод по умолчанию для print, printf. По умолчанию $stdout                                             |
| $_             | Последняя полученная методами gets или readline строка                                                 |
| $0             | Содержит имя выполняемого в данный момент скрипта. Может быть переопределен                            |
| $*             | Параметры командной строки, переданные скрипту                                                         |
| $$             | Идентификатор процесса Ruby, который выполняет данный скрипт                                           |
| $?             | Статус выполнении последнего запущенного дочернего процесса                                            |
| $:             | Путь загрузки для скриптов и бинарных модулей для инструкций «load» или «require»                      |
| $"             | Массив, который содержит имена модулей, загруженных инструкцией «require»                              |
| $DEBUG         | Состояние опции -d                                                                                     |
| $FILENAME      | Имя файла ввода из переменной $<. Аналогично вызову $<.filename                                        |
| $LOAD_PATH     | Синоним $:                                                                                             |
| $stderr        | Стандартный вывод ошибок                                                                               |
| $stdin         | Стандартный ввод                                                                                       |
| $stdout        | Стандартный вывод                                                                                      |
| $VERBOSE       | Флаг подробного вывода сообщений, который устанавливается опцией ruby -v                               |
| $-0            | Синоним $/                                                                                             |
| $-a            | True, если опция -a установлена. Только чтение                                                         |
| $-d            | Синоним $DEBUG.                                                                                        |
| $-F            | Синоним $;                                                                                             |
| $-I            | Синоним $:                                                                                             |
| $-l            | True, если опция -l установлена. Только чтение                                                         |
| $-p            | True, если опция -p установлена. Только чтение                                                         |
| $-v            | Синоним $VERBOSE                                                                                       |
| $-w            | True, если опция -w установлена10                                                                      |

## 3.3. Предопределенные глобальные константы

| Имя переменной    | Описание                                                                                   |
|-------------------|--------------------------------------------------------------------------------------------| 
| TRUE              | true                                                                                       |
| FALSE             | false                                                                                      |
| NIL               | nil                                                                                        |
| STDIN             | Стандартный ввод. По умолчанию $stdin                                                      |
| STDOUT            | Стандартный вывод. По умолчанию $stdout                                                    |
| STDERR            | Стандартный вывод ошибок. По умолчанию $stderr                                             |
| ENV               | Хеш (коллекция пар ключ — значение), который содержит переменные окружения                 |
| ARGF              | Синоним $<                                                                                 |
| ARGV              | Синоним $*                                                                                 |
| DATA              | Бинарные данные за директивой \_\_END__ в коде, если она присутствует. Иначе не определена |
| RUBY_VERSION      | Строка версии Ruby (константа VERSION устарела)                                            |
| RUBY_RELEASE_DATE | Строка даты выпуска Ruby                                                                   |
| RUBY_PLATFORM     | Идентификатор платформы                                                                    |

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.Практика.md)
