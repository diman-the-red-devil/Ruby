# Ruby / Урок 03. Синтаксис

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.Практика.md)

***

***Ruby*** — полностью объектно-ориентированный язык. 
В нём все данные являются объектами, в отличие от многих других языков, где существуют примитивные типы. 
Каждая функция — метод.
Любая конструкция в Ruby возвращает значение. 

**Ruby** является мультипарадигменным языком, он поддерживает:
 
* процедурный стиль (определение функций и переменных вне классов)
* объектно-ориентированный (всё — объект)
* функциональный (анонимные функции, замыкания, возврат значения всеми инструкциями, 
возврат функцией последнего вычисленного значения) 

**Ruby** поддерживает рефлексию, метапрограммирование, информацию о типах переменных на стадии выполнения.

Все файлы **Ruby** будут иметь расширение **.rb**. 

## Пробельные символы в программе Ruby

Пробельные символы, такие как пробелы и табуляция, обычно игнорируются в коде Ruby, 
за исключением случаев, когда они появляются в строках. 
Иногда, однако, они используются для интерпретации неоднозначных утверждений. 
Интерпретации этого типа вызывают предупреждения, когда опция -w включена.

Пример
a + b is interpreted as a+b ( где есть локальная переменная)
a  +b is interpreted as a(+b) ( Здесь вызов метода)

## Окончания строк в программе Ruby

Ruby интерпретирует точки с запятой и символы новой строки как конец оператора. 
Однако, если Ruby встречает операторы, такие как +, – или обратная косая черта в конце строки, 
они указывают на продолжение оператора.

## Комментарии

однострочный
some_useful_var = 42

another_useful_var = 7 # однострочный

=begin
блочный комментарий
=end

## Идентификаторы Ruby

Ruby — регистро-зависимый язык, прописные и строчные буквы в идентификаторах являются различными. 
Все ключевые слова языка, за двумя исключениями, пишутся в нижнем регистре.
Это означает, что RRam и RAM – два разных идентификатора в Ruby.

До версии 2.0 язык использовал множество символов 7-битной кодировки ASCII. 
Начиная с версии 2.0 поддерживается Unicode, по умолчанию файлы исходного кода используют кодировку UTF-8. 
Все буквенные символы Unicode допускается использовать в идентификаторах наравне с английскими буквами. 
Полностью поддерживаются Unicode-строки.

## Зарезервированные слова

Список ключевых слов Ruby:

alias     and     BEGIN  begin   break  case   class   def
defined?  do      else   elsif   END    end    ensure  false
for       if      in     module  next   nil    not     or
redo      rescue  retry  return  self   super  then    true
undef     unless  until  when    while  yield

Эти зарезервированные слова не могут использоваться как постоянные или переменные имена. 
Однако они могут использоваться в качестве имен методов.

## Соглашения об именовании

Идентификаторы традиционно должны состоять из букв, цифр и знаков подчёркивания 
и начинаться с буквы или знака подчёркивания. 

(A-Za-z0-9) and underscores (_), but may not begin with a digit (0-9).

Ruby использует соглашение об именовании:

Имена, начинающиеся с прописной буквы, обозначают константы и классы.
Имена, начинающиеся со строчной буквы или одиночного знака подчёркивания, обозначают локальные переменные и методы класса.
Также используются префиксы имён, определяющие область видимости идентификатора:

Префикс @ обозначает переменную экземпляра (см. ниже[⇨]).
Префикс @@ обозначает переменную класса (см. ниже[⇨]).
Префикс $ обозначает глобальную переменную или константу. Также он используется в именах предопределённых системных переменных.
Префикс : обозначает символ (экземпляр класса Symbol, см. ниже[⇨]).
Для имён методов применяются суффиксы, обозначающие назначение метода:

Суффикс ! обозначает деструктивный метод класса, то есть такой метод, вызов которого изменяет объект, для которого он вызван.
Суффикс ? обозначает предикат, то есть метод класса, возвращающий логическое значение.

## Структура программы

Программа на Ruby представляет собой текстовый файл, содержащий последовательность инструкций — команд и описаний. 
При запуске программного файла на исполнение интерпретатор последовательно читает файл и выполняет инструкции. 
В Ruby не требуется организовывать тело главной программы в виде специального программного модуля (подобно функции main() в языке Си), 
составляющие его команды просто записываются непосредственно в тексте файла программы. 
Поскольку программный файл обрабатывается интерпретатором последовательно, любые функции, методы, 
описания должны предшествовать в тексте программы их первому использованию.

Программа может быть разделена на несколько файлов. 
В этом случае главный файл программы должен загрузить остальные файлы с помощью инструкции require или require_relative:

По данной инструкции происходит поиск файла с указанным именем и расширением '.rb' и его загрузка. 
Если файла исходного кода с таким именем нет, 
интерпретатор пытается загрузить динамическую библиотеку с тем же именем (расширения зависят от операционной системы). 


Пути поиска файлов определяются инструкцией загрузки: require использует для загрузки набор каталогов, заданных настройками среды и параметрами запуска интерпретатора, а require_relative загружает файл с указанным путём относительно текущего файла (то есть в примере выше, если файл, содержащий инструкции загрузки, находится в каталоге /home/programmer/work/ruby/testproject, то файл package2.rb будет загружаться из /home/programmer/work/ruby/testproject/pkgs. При загрузке программный модуль обрабатывается интерпретатором, то есть выполняются все его инструкции. Если модуль загружается в нескольких файлах, то его загрузка происходит только один раз. В Ruby имеется метод load, также выполняющий загрузку файла исходного кода либо библиотеки, он несколько отличается функциональностью и обычно применяется для загрузки бинарных модулей, написанных на Си.

Here Document в Ruby
«Here Document» означает строковые строки из нескольких строк. После << вы можете указать строку или идентификатор для завершения строкового литерала, а все строки, следующие за текущей строкой до терминатора, – это значение строки.

Если терминатор цитируется, тип кавычек определяет тип линейного литерала строки. Обратите внимание, что между << и терминатором не должно быть пробелов.

Вот несколько примеров:

#!/usr/bin/ruby -w

print <<EOF
   Это первый способ создания
вот документ, т.е. множественные строки.
EOF

print <<"EOF";                # так же как выше
   Это второй способ создания
вот документ, т.е. множественные строки.
EOF

print <<`EOC`                 # выполнение команды
	echo привет
	echo много здесь
EOC

print <<"foo", <<"bar"  # вы можете сложить их
	Я сказал foo.
foo
	IЯ сказал bar.
bar
 

Это приведет к следующему результату:

   Это первый способ создания
   вот документ, т. е. множественные строки.
   Это второй способ создания
   вот документ, т.е. множественные строки.
привет
много здесь
      Я сказал foo.
      Я сказал bar.
Заявление BEGIN на Ruby
Синтаксис
BEGIN {
   code
}
 

Объявляет код, который вызывается до запуска программы.

Пример
#!/usr/bin/ruby

puts "Это основная программа Ruby"

BEGIN {
   puts "Инициализация программы Ruby"
}
 

Это приведет к следующему результату –

Инициализация программы Ruby
Это основная программа Ruby
Заявление Ruby END
Синтаксис
END {
   code
}
 

Объявляет код, который будет вызываться в конце программы.

#!/usr/bin/ruby

puts "Это основная программа Ruby"

END {
   puts "Завершение программы Ruby "
}
BEGIN {
   puts "Инициализация программы Ruby"
}
 

Это приведет к следующему результату:

Инициализация программы Ruby
Это основная программа Ruby
Завершение программы Ruby 
***


Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.Практика.md)