# Ruby / Урок 04. Комментарии

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.Практика.md)

***

***Ruby*** — полностью объектно-ориентированный язык. 
В нём все данные являются объектами, в отличие от многих других языков, где существуют примитивные типы. 
Каждая функция — метод.

>Любая конструкция в Ruby возвращает значение. 

**Ruby** является мультипарадигменным языком, он поддерживает:
 
* процедурный стиль (определение функций и переменных вне классов)
* объектно-ориентированный (всё — объект)
* функциональный (анонимные функции, замыкания, возврат значения всеми инструкциями, 
возврат функцией последнего вычисленного значения) 

**Ruby** поддерживает рефлексию, метапрограммирование, информацию о типах переменных на стадии выполнения.


## 1. Программа на Ruby

### 1.1. Файлы программ Ruby

Программа на **Ruby** представляет собой текстовый файл с расширением **.rb**, 
содержащий последовательность инструкций — команд и описаний. 

Программа может быть разделена на несколько файлов. 
В этом случае главный файл программы должен загрузить остальные файлы 
с помощью инструкции **require** или **require_relative**.
По данной инструкции происходит поиск файла с указанным именем (с расширением **.rb**) и его загрузка. 
Если файла исходного кода с таким именем нет, интерпретатор пытается загрузить динамическую библиотеку с тем же именем 
(расширения зависят от операционной системы). 

Пути поиска файлов определяются инструкцией загрузки: 

* **require** использует для загрузки набор каталогов, заданных настройками среды и параметрами запуска интерпретатора
* **require_relative** загружает файл с указанным путём относительно текущего файла 

*Пример:*

```ruby
require 'module1'       # загрузка программного файла с именем 'module1.rb' либо библиотеки с именем 'module1'
require 'pkgs/package2' # загрузка программного файла 'package2' из подкаталога pkgs
```

*Результат:*

Если файл, содержащий инструкции загрузки, находится в каталоге */home/programmer/work/ruby/testproject*, 
то файл *package2.rb* будет загружаться из */home/programmer/work/ruby/testproject/pkgs*.

При загрузке программный модуль обрабатывается интерпретатором, то есть выполняются все его инструкции. 

>Если модуль загружается в нескольких файлах, то его загрузка происходит только один раз. 

В Ruby имеется метод **load**, также выполняющий загрузку файла исходного кода либо библиотеки, 
он несколько отличается функциональностью и обычно применяется для загрузки бинарных модулей, написанных на **C**.

### 1.2. Выполнение программ Ruby

Интерпретатор **Ruby** проводит синтаксический анализ программы как последовательность лексем. 
Лексемы состоят из комментариев, литералов, знаков пунктуации, идентификаторов и ключевых слов.
При запуске программного файла на исполнение интерпретатор последовательно читает файл и выполняет инструкции. 
Поскольку программный файл обрабатывается интерпретатором последовательно, любые функции, методы, 
описания должны предшествовать в тексте программы их первому использованию.

### 1.3. Структура программы Ruby

Программа на **Ruby** состоит из отдельных строк, как в **C**, но не как в древних языках наподобие **FORTRAN**. 
В одной строке может быть сколько угодно лексем, лишь бы они правильно отделялись пропусками.
В одной строке может быть несколько предложений, разделенных точками с запятой (**;**).
только в этом случае точка с запятой и необходима. 

В современных версиях **Ruby** логические выражения и последовательности вызова методов можно переносить на несколько
строк. В ранних версиях **Ruby** (до версии 1.9) для этого необходимо было использовать  
символ переноса строки "\" — обратную косую черту.

В **Ruby** не требуется организовывать тело главной программы в виде специального программного модуля 
(подобно функции main() в **Си**), составляющие его команды просто записываются непосредственно 
в тексте файла программы. 

### 1.4. Разделители в программе Ruby

Пробельные символы, такие как пробелы и табуляция, обычно игнорируются в коде **Ruby**, 
за исключением случаев, когда они появляются в строках. 
Иногда, однако, они используются для интерпретации неоднозначных утверждений. 
Интерпретации этого типа вызывают предупреждения, когда опция -w включена.

*Пример:*

```ruby
a + b
a  +b
```

*Результат:*

Первая строка интерпретируется как a+b (Сложение двух локальных переменных).
Вторая строка интерпретируется как  a(+b) (Вызов метода).

**Ruby** интерпретирует точки с запятой и символы новой строки как конец оператора. 
Однако, если **Ruby** встречает операторы, такие как +, – или обратная косая черта в конце строки, 
они указывают на продолжение оператора.

***

## 2. Комментарии

### 2.1. Однострочные комментарии

Однострочные комментарии в **Ruby** начинается с символа решетка **#** и продолжается до конца строки.
Интерпретатор игнорирует **#** и любой текст, который за ним следует.
Но не игнорирует символ новой строки, который является значащим неотображаемым символом 
и может служить признаком конца предложения.

>Если **#** находится внутри строки или литерала регулярного выражения, 
то он является лишь частью этой строки или регулярного выражения и не представляет комментария. 

*Пример:*

```ruby
# Вся эта строка является комментарием
some_useful_var = 42
another_useful_var = 7 # Однострочный комментарий
x = "# Это строка" # А это комментарий
y = /# Это регулярное выражение/ # Это еще один комментарий
```

Обычно при написании многострочных комментариев в начале каждой строки ставится отдельный символ #.

*Пример:*

```ruby
#
# Этот класс представляет комплексное число (Complex)
# Несмотря на его название (другое значение слова Complex - сложное),
# сам по себе он особой сложности не представляет
#
```

Способ вставки комментария в середину строки программного кода в нем не предусмотрен

### 2.2. Многострочные комментарии

В **Ruby** поддерживается другой стиль многострочного комментария, известный как **встроенный документ**. 
Он берет свое начало со строки, начинающийся с **=begin** и продолжается вплоть до строки, начинающейся с **=end**.
Любой текст, появляющийся после **=begin** и **=end**, является частью комментария, который также игнорируется,
но дополнительный текст должен быть отделен от **=begin** и **=end** хотя бы одним пробелом.

>Встроенный документ - удобный способ закомментировать длинные блоки кола, избавляющий от необходимости вставлять 
в начале каждой строки символ **#**.

*Пример:*

```ruby
=begin Нужно выключить следующий дефектный код!
  Любой код, расположенный здесь будет задокументирован
=end
```

>Встроенный документ будет работать лишь в том случае, если первым в строке будет **#**.

*Пример:*

```ruby
# =begin Так начинается комментарий. Теперь эта строка сама себя закомментировала!
   Теперь расположенный здесь код уже не будет задокументирован
# =end
```

Как следует из их названия, встроенные документы могут использоваться для включения 
в текст программы длинных блоков документации или для встраивания в **Ruby** программу исходного кода на другом языке 
(к примеру **HTML** или **SQL**). 

Обычно встроенные документы предназначены для применения некоторыми инструментальными средствами постобработки, 
использующих исходный код **Ruby** и для них характерным продолжением **=begin** является идентификатор, 
указывающий на тот инструмент, для которого написан комментарий.

### 2.3. Комментарии, используемые для документирования 

**Ruby** программы могут включать встроенную документацию в виде специально отформатированных комментариев, 
которые предшествуют определениям методов, классов и модулей. Эту документацию можно просматривать с помощью **ri**,
инструментального средства.

Инструментальное средство **rdoc** извлекает комментарии, используемые для документирования из исходного кода **Ruby**, 
придавая им формат HTML или подготавливая их для просмотра в **ri**.

Комментарии, используемые для документирования, должны располагаться непосредственно перед тем модулем, 
классом или методом, чей API они документируют. Обычно они оформляются в виде многострочного комментария, 
каждая строка оторого начинается с символа **#**, но они также могут быть созданы в форме встроенного документа, 
начинающегося с **=begin rdoc**

>Если опустить **rdoc**, то инструментальное средство **rdoc** не станет обрабатывать этот комментарий.

В следующем примере комментариев показаны наиболее важные элементы форматирования, 
входящие в основы разметки комментариев **Ruby**, используемых для документирования.

*Пример:*

```ruby
#
# Комментарии rdoc используют простую грамматику разметки, подобнкю той, что
# используется в Wiki
#
# Разделение абзацев производится пустой строкой.
# 
# = Загловки
#
# Заголовок начинается со знака равенства
#
# == Подзаголовки
#
# Показанная выше строка создает подзаголовок
#
# === Более глубокий подзаголовок
#
# И т. д.
#
# = Примеры
#   
#   Строки с отступом используются, чтобы точно отобразить начертание кода.
#   Но для заголвков и списков отступы лучше не использовать.
#
# = Списки и шрифты
# 
# Маркированный список элементов начинается с * или -.
# 
# Шрифты задаются знаками пунктуации или HTML 
# * _курсив_ или <i>несколько слов, отмеченных курсивом</i>
# * *полужирный* или <b>несколько слов, отмеченных полужирным шрифтом</b>
# * +код или <tt>несколько слов, отмеченных в формате кода</tt>
#
# Пронумерованный список элементов начинается с номера.
#
# 100. Можно использовать любой номер: последоватльность соблюдать необязательно 
# 1. Способ вложения списков отсуствует
# 
# Пункты списка описаний заключаются в квадратные скобки:
# [Пункт 1] Описание пункта 1
# [Пункт 2] Описание пункта 2
#
```

## 3. Идентификаторы Ruby

**Ruby** — регистро-зависимый язык, прописные и строчные буквы в идентификаторах являются различными. 

>Все ключевые слова языка, за двумя исключениями, пишутся в нижнем регистре.

Это означает, что RRam и RAM – два разных идентификатора в Ruby.

До версии 2.0 язык использовал множество символов 7-битной кодировки ASCII. 
Начиная с версии 2.0 поддерживается Unicode, по умолчанию файлы исходного кода используют кодировку UTF-8. 
Все буквенные символы Unicode допускается использовать в идентификаторах наравне с английскими буквами. 
Полностью поддерживаются Unicode-строки.

### 3.1. Зарезервированные слова

Список ключевых слов **Ruby**

|          |        |       |        |       |       |        |       |
|----------|--------|-------|--------|-------|-------|--------|-------|
| alias    | and    | BEGIN | begin  | break | case  | class  | def   |
| defined? | do     | else  | elsif  | END   | end   | ensure | false |
| for      | if     | in    | module | next  | nil   | not    | or    |
| redo     | rescue | retry | return | self  | super | then   | true  |
| undef    | unless | until | when   | while | yield |        |       |

Эти зарезервированные слова не могут использоваться как постоянные или переменные имена. 
Однако они могут использоваться в качестве имен методов.

### 3.2. Соглашения об именовании

Идентификаторы **Ruby** традиционно должны состоять из букв (A-Z, a-z), цифр (0-9) и 
знаков подчёркивания (_) и начинаться с буквы или знака подчёркивания. 

Ruby использует соглашение об именовании:

* имена, начинающиеся с прописной буквы, обозначают **константы** и **классы**

* имена, начинающиеся со строчной буквы или одиночного знака подчёркивания, обозначают **локальные переменные** и **методы класса**

Также используются *префиксы* имён, определяющие *область видимости идентификатора*:

* префикс **@** обозначает переменную экземпляра

* префикс **@@** обозначает переменную класса

* префикс **$** обозначает глобальную переменную или константу

>Также он используется в именах предопределённых системных переменных.

* префикс **:** обозначает символ (экземпляр класса Symbol)

Для имён методов применяются *суффиксы*, обозначающие *назначение метода*:

* суффикс **!** обозначает деструктивный метод класса, 
то есть такой метод, вызов которого изменяет объект, для которого он вызван

* суффикс **?** обозначает предикат, 
то есть метод класса, возвращающий логическое значение

***

## 4. Here Document в Ruby

**Here Document (HEREDOC)** - блок текста (документации) в коде и его передача в переменные. 

После **<<** вы можете указать строку или идентификатор для завершения строкового литерала, 
а все строки, следующие за текущей строкой до терминатора, – это значение строки.

>Если терминатор цитируется, тип кавычек определяет тип линейного литерала строки. 

>Между **<<** и терминатором не должно быть пробелов.

Способы создания **HEREDOC**:

* **<<EOF**

Конструкция чувствительная к форматированию.
Код содержащийся внутри идентификатора не читается буквально и не покажет отступы при выводе в терминале.

*Пример:*

```ruby
print <<EOF
   Это первый способ создания
вот документ, т.е. множественные строки.
EOF
``` 

*Результат:*

```text
   Это первый способ создания
   вот документ, т.е. множественные строки.
```

* **<<"EOF";**

Двойные кавычки можно использовать в конструкции, но они дают такой же результат, 
как и их полное отсутствие.

*Пример:*

```ruby
print <<"EOF";                # так же как выше
   Это второй способ создания
вот документ, т.е. множественные строки.
EOF
``` 

*Результат:*

```text
   Это второй способ создания
   вот документ, т.е. множественные строки.
```

* **<<'EOF'**

Интерполирует Ruby код в документации.

*Пример:*

```ruby
print <<`EOC`
    Случайное число #{@rand_number} + 1 = #{@rand_number + 1}
EOC
``` 

*Результат:*

```text
Случайное число #{@rand_number} + 1 = #{@rand_number + 1}
```

* **<<-EOF**

Конструкция нечувствительная к форматированию.
Код содержащийся внутри идентификатора читается буквально и покажет отступы при выводе в терминале.

*Пример:*

```ruby
print <<-EOF
    Конструкция нечувствительная к форматированию.
Код содержащийся внутри идентификатора читается буквально и 
    покажет отступы при выводе в терминале.
EOF
``` 

*Результат:*

```text
    Конструкция нечувствительная к форматированию.
Код содержащийся внутри идентификатора читается буквально и 
    покажет отступы при выводе в терминале.
```

* **<<~EOF**

Удаляет все отступы в начале строк, принимает самый короткий отступ в качестве эталона. 
Все более длинные отступы будут обрезаны ровно по него. 
Позволяет форматировать документацию и исключать ненужные отступы.

>Пустые строки и строки, состоящие исключительно из буквальных табуляций и пробелов, 
будут игнорироваться для определения отступов, 
но экранированные табуляции и пробелы считаются не отступными символами.

*Пример:*

```ruby
print <<~EOF
            Удаляет все отступы в начале строк, принимает самый короткий отступ в качестве эталона. 
        Все более длинные отступы будут обрезаны ровно по него. 
    Позволяет форматировать документацию и исключать ненужные отступы.
EOF
``` 

*Результат:*

```text
        Удаляет все отступы в начале строк, принимает самый короткий отступ в качестве эталона. 
    Все более длинные отступы будут обрезаны ровно по него. 
Позволяет форматировать документацию и исключать ненужные отступы.
```

**HEREDOC** позволяет использовать Ruby код внутри себя, 
что позволяет делать документацию динамической.

*Пример:*

```ruby
@rand_number = rand(10)

def some_method
  <<~something
    Случайное число #{@rand_number} + 1 = #{@rand_number + 1}
  something
end

puts some_method
``` 

*Результат:*

```text
Случайное число 9 + 1 = 10
```

Существует способ комбинирования **HEREDOC**.

*Пример:*

```ruby
@rand_number = rand(10)

def some_method
  puts(<<~first, <<~second)
    Текст первого хирдока
  first
    Текст второго хирдока
  second
end

some_method
``` 

*Результат:*

```text
Текст первого хирдока
Текст второго хирдока
```

***
 
## 5. Заявления BEGIN и END 
      
### 5.1. Заявление BEGIN

**Заявление BEGIN** объявляет код, который вызывается до запуска программы.

Синтаксис

```ruby
BEGIN {
   code
}
```

*Пример:*

```ruby
puts "Это основная программа Ruby"

BEGIN {
   puts "Инициализация программы Ruby"
}
```

*Результат:*

```text
Инициализация программы Ruby
Это основная программа Ruby
```


### 5.2. Заявление END

**Заявление END** объявляет код, который будет вызываться в конце программы.

Синтаксис

```ruby
END {
   code
}
```

*Пример:*


```ruby
puts "Это основная программа Ruby"

END {
   puts "Завершение программы Ruby "
}
BEGIN {
   puts "Инициализация программы Ruby"
}
``` 

*Результат:*

```text
Инициализация программы Ruby
Это основная программа Ruby
Завершение программы Ruby 
```

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.Практика.md)